# 均摊分析

## 一、均摊分析原理

关注一系列的==数据结构==上的操作的时间复杂度，注意操作之间实际上是==相互关联==的不是独立的，所以考虑最坏时间的时候要考虑操作受数据结构的约束。

正确分析：三种方法

1. 聚合分析：每个操作的代价，所有操作的上界，然后除以操作数
2. 会计分析：整个操作序列的代价，使用预付代价的方式处理
3. 势能分析：不同类型操作赋予不同的均摊代价，预付代价作为整个数据结构的是能

## 二、均摊分析

==分析每个操作的复杂性上界==

### **例1：multipop(S, k): 去掉S的k个栈顶对象，如果k>|S|弹出整个栈。初始栈为空的n个栈操作序列分析如下：**

1. 不能只关注操作，忽略了数据结构，每个操作不能单独分析。
2. 粗略分析： T(n)/n = O(n$^2$) / n = O(n)，没有考虑栈的性质。
3. 正确分析： 因为初始的栈为空，所以multipop和pop总次数不会超过push的次数，而push的次数不超过n，所以最坏情况下的操作代价序列的代价T(n)<=n+n=2n，所以平摊代价T(n)/n=O(1)

### **例2：二进制计数器：从0开始计数的k位二进制计数器，输入k位二进制变量x，初始0，输出x+1 mod 2$^k$**

1. 粗略分析：每个+1操作，最多时间代价为O(k)，考虑进位。均摊代价为O(k)？太粗糙了
2. 精细分析：对每一个二进制位进行分析，第一位操作一次发生变化，第二位操作2次发生变化，...，第k位操作2$^k$次发生变化。所以对于第i位，总变化次数为n/2$^i$。因此T(n)=n+n/2+n/4+...+n/2$^k$=2(1-0.5$^{k+1}$)n<2n. 因此均摊代价为T(n)/n=O(1)

## 三、会计方法

==为每个操作分配不同的平摊代价，这个代价可能比实际打，也有可能比实际小。最后把重新赋予的总代价作为上界进行一个估计，把CREDIT和数据结构中的具体对象进行关联==

- 如果均摊代价比实际大，一部分抵消实际代价，另一部分作为**Credit**附加在数据结构的具体数据对象上。
- 如果均摊代价比实际小，使用**Credit**来补充支付实际代价，<font color='red'>Credit必须任何时候都非负！</font>

平摊代价的选择规则：

$\alpha_i$是操作的平摊代价。$c_i$是实际代价，那么必须有$\sum_{1\leq i\leq n}\alpha_i -\sum_{1\leq i\leq n}c_i\geq0$

### **例1 栈操作序列分析（带MULTIPOP）**

|   操作   | 实际代价 | 均摊代价 |
| :------: | :------: | :------: |
|   PUSH   |    1     |    2     |
|   POP    |    1     |    0     |
| MULTIPOP | min{k,S} |    0     |

$\alpha({PUSH})$=2的原因是一个1来抵消实际开销，另一个1作为Credit预支所有POP的开销

那么$\sum_{1\leq i\leq n}\alpha_i -\sum_{1\leq i\leq n}c_i\geq0=$2倍PUSH的次数-1倍PUSH的次数-所有POP的次数=栈剩余的元素个数$\geq 0$

所以总栈操作代价T(n)$\leq$2n=O(n)，故总均摊代价为O(1)



### **例2 二进制计数器+1操作序列分析**

|   操作    | 实际代价 | 均摊代价 |
| :-------: | :------: | :------: |
| INCREMENT |    1     |    2     |

$\alpha({INCREMENT})$=2的原因是一个1来抵消实际开销，另一个1作为Credit预支所有位从1变0的开销

那么$\sum_{1\leq i\leq n}\alpha_i -\sum_{1\leq i\leq n}c_i=$2倍置1的次数-1倍置0操作-1倍置1操作 $\geq0$，因为每次置0之前一定有一个置1操作在前。所以总代价位O(n)，均摊代价位O(1)

## 四、势能分析

==把Credit和整个数据结构关联，所有余额作为数据结构的势能==

- 如果操作平摊代价大于操作的实际代价，势能增加
- 如果操作平摊代价小于操作的实际代价，势能减少，使用势能支付实际代价

势能的定义：考虑在数据结构$D^{(0)}$上进行n个操作，对于一个操作i，我们有

- 实际代价$c_i$
- 操作i把数据结构$D^{(0)}_{i-1}$变为$D^{(0)}_{i}$

- 势能$\phi(D_i)\geq 0$，且由势能我们可以定义操作均摊代价
- $\alpha_i=c_i+\phi(D_i)-\phi(D_{i-1})$

从而，总代价：
$$
\sum_{i=1}^n\alpha_i=\sum_{i=1}^n(c_i+\textcolor{red}{\phi(D_i)-\phi(D_{i-1}}))=\sum_{i=1}^nc_i+\textcolor{green}{\phi(D_n)-\phi(D_{0}})
$$
所以关键是对于$\phi$的定义,使得 $\forall i,\ \phi(D_i)\geq \phi(D_0)$

> 一般可以定义$\phi(D_0)=0,\phi(D_i)\geq0$

### **例1 栈操作序列分析（带MULTIPOP）**

$\phi(D_m)$定义为栈$D_m$中对象的个数，所以定义$\phi(D_0)=0$，而栈中的元素不可能小于0，所以我们也有$\phi(D_i)\geq 0$

分析均摊代价如下：假设现在有s个元素

- PUSH: $\alpha_i = c_i + \phi(D_{i})-\phi(D_{i-1})=1+(s+1)-s=2$
- POP: $\alpha_i = c_i + \phi(D_{i})-\phi(D_{i-1})=1+s-(s+1)=0$
- MULTIPOP(k): $\alpha_i = c_i + \phi(D_{i})-\phi(D_{i-1})=\min(k,s)+(s-\min(k,s))-s=0$

满足势能的条件。所以n个操作实际代价$\leq 2n$，均摊代价为O(1)



### **例2 二进制计数器+1操作序列分析**

$\phi(D_m)$定义为二进制位1的个数，所以定义$\phi(D_0)=0$，而1的个数不可能小于0，所以我们也有$\phi(D_i)\geq 0$

假设这步操作之后1的个数为$b_i$，这一步操作把$t_i$个位置变成了0. 那么

- 如果$b_i=0$，那么说明前一步全部都是1，那么$b_{i-1}=k,t_i=k$

- 如果$b_i>0$，那么$b_i=b_{i-1}-t_i+1$，因为有一位进位变1了。

所以$b_i\leq b_{i-1}-t_i+1$，所以$\alpha_i=c_i+\phi(D_i)-\phi(D_{i-1})\leq t_i+1+1-t_i=2$

所以总代价为O(n)，平均代价为O(1)

