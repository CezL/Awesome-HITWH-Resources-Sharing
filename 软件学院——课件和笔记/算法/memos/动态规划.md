# 动态规划

## 动态规划的要素

1. 分治方法的问题：如果划分出来的子问题不是相互独立的，分治方法会重复计算公共子问题，效率很低。<font color="red">但是DP就可以避免计算重复的公共子问题。</font>

2. 优化问题：找到问题的一个最优解即可（最优解不一定唯一但是找到一个就行）
3. 动态规划：把原始问题划分为一系列子问题，不同子问题的数目是多项式级别的。每个子问题只求解一次，然后把结果放在表中，**不重复计算，节省时间。自底向上**求解子问题。
4. 适用范围：可分为多个相关子问题且子问题的解可以被重复使用的这类情况
5. 使用动态规划的条件：
   1. 优化子结构：这个问题优化解包含子问题的优化解
   2. 重叠子问题：问题求解的时候子问题的解会被用很多次
6. 设计DP算法的步骤：
   1. 分析优化子结构
   2. 递归定义最优解代价
   3. 递归划分子问题
   4. 自底向上求解各个子问题（计算优化解的代价保存下来，获取构造最优解的信息）
   5. 根据构造最优解的信息构造优化解



## 问题一、矩阵链乘法

### 问题建模：

1. 输入：$<A_1,A_2,..,A_n>,A_i$是$p_{i-1}\times p_i$矩阵
2. 输出：计算$<A_1\times A_2\times ...\times A_n>$最小代价
3. 矩阵乘法的代价取决于乘法的次数，比如$p\times q$与$q\times r$相乘，所需要的代价就是O(pqr)

### 问题分析：

可以把乘积一分为二，看成两个子乘积的乘积。于是我们可以这样求出代价：

![image-20201018082500648](https://i.loli.net/2020/10/18/kBEhqlvtsRUYXKm.png)

于是我们定义优化子结构：如果红色方案是代价最小的方案，那么$A_1\times ...\times A_k$,和$A_{k+1}\times ...\times A_n$必须是代价最小的方案。定义$A_{i\sim j}$表示矩阵链$A_i\times ...\times A_j$

#### 优化解的结构：

设$A_{1\sim n}=A_{1\sim k}\times A_{k+1\sim n}$，是优化顺序，那么$A_{1\sim k}$一定的解一定是这个子问题的优化解，否则可以找到一个代价更小的优化顺序，代替这里的解，产生更小的解，矛盾。对于$A_{k+1\sim n}$同理。

#### 重叠子问题：

很显然，该问题具有子问题重叠性，计算较多元素乘积时对于子集元素乘积是使用多次的。

#### 递归求解过程：

定义最优解的代价：m[i,j]计算$A_{i\sim j}$最小乘法数
$$
m[i,j]=\left\{
\begin{array}{**lr**}
0, & if\ i=j\\
min_{i\leq k<j}(m[i,k]+m[k+1,j]+p_{i-1}p_kp_j) & if\ i<j
\end{array}
\right.
$$
![image-20201018084935198](https://i.loli.net/2020/10/18/3NB8xmaYvWDObQH.png)

所以我们需要自顶向上求解，右上元素需要左下元素得到。

#### 算法伪代码：

![image-20201018090858846](https://i.loli.net/2020/10/18/4YaSTDsXmpvHLeO.png)

数组每次按照对角线更新元素（因为更新需要），同时构造数组s记录划分的位置。

#### 构造最优解：

![image-20201018091019660](https://i.loli.net/2020/10/18/OgUwPN6EZQTiX9R.png)

利用数组s递归打印即可。

### 复杂度分析：

- 时间：O($n^3$)计算代价需要O($n^3$)，而构造优化解只需要O(n)
- 空间：m,s一共O($n^2$)

## 问题二、最长公共序列

### 问题建模：

LCS问题：

1. 输入：$X=(x_1,x_2,...,x_m), Y=(y_1,y_2,...,y_n)$
2. 输出：$X,Y$的LCS $Z=(z_1,z_2,...,z_k)$

### 问题分析：

#### 优化解的结构：

![image-20201018094959642](https://i.loli.net/2020/10/18/yq9Ane1BTNiMCt3.png)

证明：对于(1)而言，假设$z_k\neq x_m$，记$LCS_{XY}'=LCS_{XY}+x_m$，长度大于$LCS_{XY}$矛盾！对于(2)而言，$x_m\neq y_n,z_k\neq x_m$，$Z=LCS_{XY}$是$X_{m-1}$和$Y$的LCS。否则假设有比Z更长的$W$，$W$也是$X,Y$的公共子序列（因为没有$x_m$），矛盾！同理有(3)

#### 重叠子问题：

字符串的求解需要用到子串的优化解，所以有重叠性。

#### 递归求解过程：

我们记$C[i,j]=LCS(X_i,Y_j)$的长度那么我们有递归方程
$$
C[i,j]=\left\{
\begin{array}{**lr**}
0, & if\ i=0\ or\ j=0\\
C[i-1,j-1]+1, & if\  i,j>0\ and\ x_i=y_j\\
max(C[i,j-1],C[i-1,j])& if\ i,j>0\ and\ x_i\neq y_j
\end{array}
\right.
$$
![image-20201018215557090](https://i.loli.net/2020/10/18/qbznRhoWNEMUPDX.png)

用画方格的方法我们很容易看出求解的顺序。为了求解C[i,j]我们需要算出上、左、左上的元素。

![image-20201018215836337](https://i.loli.net/2020/10/18/MaPEHhKUmNfBnyc.png)

#### 算法伪代码

1. 数据结构：
   1. C[0:m,0:n]表示局部LCS的长度
   2. B[1:m,1:n]记录优化解的信息

2. 伪代码

   ![image-20201018220124478](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201018220124478.png)

#### 构造最优解

从B[m,n]开始按指针搜索，如果B[i,j]=↖,则$x_i=y_j$是LCS的一个元素。如此找到的是逆路径。我们可以打印一下信息。算法如下:

![image-20201018220454838](https://i.loli.net/2020/10/18/CZYqEgitaKPN8wk.png)

### 复杂度分析

1. 时间复杂度：

   计算代价用时O(mn)，最优解构造用时O(m+n)，总时间就是O(mn)

2. 空间复杂度：

   C,B都是$\Theta$(mn)

   >空间优化策略：
   >
   >1. B的定义duck不必，因为使用周围三项可以在O(1)时间内判断它的方向
   >2. C的定义是必须的，但是实际上用两行就行了（因为求解下一行只用了上一行，所以我们每次覆盖就行了）所以最终情况下我们需要的空间就是$\Theta(min\{m,n\})$

## 问题三、0/1背包问题(==整数情况==)

### 问题建模：

给定n种物体和一个背包，物品i重量是$w_i$，价值是$v_i$，背包承重是C，怎么选使得背包的物品总价值最大？

1. 输入：$C>0,w_i,v_i>0,1\leq i\leq n$
2. 输出：$(x_1,x_2,...,x_n),x_i\in\{0,1\}$满足$\sum_{1\leq i \leq n}w_ix_i\leq C, s.t.\ \sum_{1\leq i \leq n}v_ix_i$

### 问题分析：

naive solution；枚举法：$O(n2^n)$

#### 优化解的结构：

1. 问题划分

![image-20201018222559371](https://i.loli.net/2020/10/18/YOQdNtJjGuqIl7K.png)

2. 子问题：

![image-20201018222713703](https://i.loli.net/2020/10/18/TU8lrkHcwLSnpJs.png)

3. 定理：

   ![image-20201018222944187](https://i.loli.net/2020/10/18/Rl8FPqsCuGrQ7pn.png)

简而言之就是，取出一项的子问题的优化解是问题的优化解的一部分。

#### 递归求解过程：

定义m(i,j)为[(i,i+1,...,n),j]的优化解$(x_i,x_{i+1},...,x_{n})$的代价，m(i,j)=$\sum_{i\leq k\leq n}v_kx_k$

#### 算法伪代码

$$
m(n,j)=\left\{
\begin{array}{**lr**}
0,&0\leq j<w_n\\
v_n,&j\geq w_n\\
m(i+1,j),&0\leq j< w_i\\
max\{m(i+1,j),m(i+1,j-w_i)+v_i\},&j\geq w_i
\end{array}
\right.
$$

注意到m的信息需要通过下和左下的信息求出。

本算法只适用于==整数情况==。

![image-20201019000117686](https://i.loli.net/2020/10/19/Hb2YvicujCGEKLt.png)

![image-20201019000200659](https://i.loli.net/2020/10/19/G9DHqMsZ4nQ3CTu.png)

边界条件需要单独考虑。

常数优化：

![image-20201019000723761](https://i.loli.net/2020/10/19/PrkjSXOqi3tVCdv.png)

#### 构造最优解

$$
if\ m(1,C)=m(2,C)\\
Then\ x_1=0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\
Else\ x_1=1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
$$

如果$x_1=0$，通过m(2,C)继续构造最优解。

如果$x_1=1$，通过m(2,C-$w_1$)继续构造最优解。

### 复杂度分析

1. 时间复杂度：代价O(Cn)，构造最优解O(n)，总O(c(n))
2. 空间复杂度：使用的m，O(Cn)

## 最优二叉搜索树

### 问题建模：

![image-20201019002313524](https://i.loli.net/2020/10/19/gf1ievot8xVJUwj.png)

叶子节点比非叶子节点多一个。

搜索树的期望代价：
$$
E(T)=\sum_{i=1}^n(DEP_T(k_i)+1)p_i+\sum_{j=0}^n(DEP_T(d_i)+1)q_i
$$

1. 输入：
   1. K={$k_1,k_2,...,k_n$}升序
   2. P={$p_1,p_2,...,p_n$}
   3. Q={$q_0,q_1,...,q_n$}
2. 输出：构造K的二叉搜索树T，使得(5)最小

### 问题分析：

#### 优化解的结构：

![image-20201019003146357](https://i.loli.net/2020/10/19/QxwHFA1683WkhXj.png)

定理：如果T包含具有关键字集合的{$k_i,k_{i+1},...,k_j$}子树T'那么T'是关于此关键字集合的子问题的优化解。

证明：否则，设有此关键字集合子树T'',且T''的期望搜索代价小于T'.那么我们直接用T''代替T'可以得到一个期望搜索代价更小的原始问题的二叉搜索树。所以矛盾。
$$
\begin{align}
E(T) & =\sum_{i=1}^n(DEP_{T}(k_i)+1)p_i+\sum_{j=0}^n(DEP_{T}(d_i)+1)q_i\\
 & =\sum_{i=1}^n(DEP_{T'}(k_i)+1)p_i+\sum_{j=0}^n(DEP_{T'}(d_i)+1)q_i+\\ & \sum_{i=1}^n(DEP_{T-T'}(k_i)+1)p_i(常量1)+\sum_{j=0}^n(DEP_{T-T'}(d_i)+1)q_i(常量2)\\
& <\sum_{i=1}^n(DEP_{T''}(k_i)+1)p_i+\sum_{j=0}^n(DEP_{T''}(d_i)+1)q_i+\\ & \sum_{i=1}^n(DEP_{T-T'}(k_i)+1)p_i(常量1)+\sum_{j=0}^n(DEP_{T-T'}(d_i)+1)q_i(常量2)
\end{align}
$$

因此我们只需要计算出两棵子树的优化解，就可以算出T的优化解，<font color='red'>注意下深度+1了</font>。（注意一下边界条件）

#### 重叠子问题：

需要用到子树的求解，且划分方式多样性导致子问题重叠性。

#### 递归求解过程：

$$
E(i,j)=P_r+E(i,r-1)+W(i,r-1)+E(r+1,j)+W(r+1,j)
$$

W是对于深度的修正（因为子树深度减一了）。$r$是树根

推导如下,利用做差法求W：
$$
E(left+1)=\sum_{l=i}^{r-1}(DEP_{left}(k_l)+2)p_l+\sum_{l=i-1}^{r-1}(DEP_{left}(d_l)+2)q_l
$$

$$
E(left)=\sum_{l=i}^{r-1}(DEP_{left}(k_l)+1)p_l+\sum_{l=i-1}^{r-1}(DEP_{left}(d_l)+1)q_l
$$

做差有$W(i,r-1)=\sum_{l=i}^{r-1}p_l+\sum_{l=i-1}^{r-1}q_l$

同理, $W(r+1,j)=\sum_{l=r+1}^jp_l+\sum_{l=r}^jq_l$
$$
W(i,j)=W(i,r-1)+W(r+1,j)+p_r=W(r+1,j)=\sum_{l=i}^jp_l+\sum_{l=i-1}^jq_l=W(i,j-1)+p_j+q_j
$$
特别的，$W(i,i-1)=q_{i-1}$

那么可以求出$E(i,j)=E(i,r-1)+E(r+1,j)+W(i,j)$

得到如下结论：

<font color='red'>$W(i,j)=q_i-1,\\ W(i,j)=W(i,j-1)+p_j+q_j\\ E(i,i-1)=q_{i-1},\\ E(i,j)=min_{i\leq r \leq j}\{E(i,r-1)+E(r+1,j)+W(i,j)\}\ if\ j\geq i$</font>

#### 算法伪代码

![image-20201019082113449](https://i.loli.net/2020/10/19/ORqXgJfhmBEv1cQ.png)

我们需要求出左边和下面的元素。

#### 构造最优解

![image-20201019082957037](https://i.loli.net/2020/10/19/CdtMDykFb9xHQsG.png)

- E[1:n+1,0:n]:优化解
- E[1:n+1,0:n]:存储代价增量
- Root[1:n,1:n]:记录优化解的根

![image-20201019083751876](https://i.loli.net/2020/10/19/ZxqFQup1cyV8teN.png)对角线更新。

优化解的构造方法：

1. 使用递归

   ![image-20201019084002917](https://i.loli.net/2020/10/19/Ji2boG1WX9Zg4HR.png)

2. 使用栈

   ![image-20201019084053287](https://i.loli.net/2020/10/19/JXUwKQkIsgt9P3N.png)

3. 打印T

   ![image-20201019084115905](https://i.loli.net/2020/10/19/GazPmdrlHesUyQc.png)

   

### 复杂度分析

1. 时间复杂性：三层循环$O(n^3)$

2. 空间复杂性：两个数组$(n+1)\times (n+1)$，是$O(n^2)$

   

## 最小编辑距离

### 问题建模：

1. 输入：两个字符串x[1..m],y[1..n]
2. 输出：将x[1..m]转换为y[1,,n]所需要的最小操作数。其中操作只有**插入、删除、替换**一个符号。

### 问题分析：

#### 优化解的结构：

$ED[i,j]$，字符串x[1:i], y[1:j]的编辑距离。

编辑序列的性质：

- 不重叠性：每个字符只执行一次编辑操作
- 顺序无关：操作顺序冲排列不改变编辑结果
- 对称性：s编辑为t和t编辑为s是一样的

我们将x[1:m]转化为y[1:n]

![image-20201019091529723](https://i.loli.net/2020/10/19/upVCHDUhdo5vtZw.png)

![image-20201019092014677](https://i.loli.net/2020/10/19/TEDNF4m8Xb7nwq9.png)

x的最后一个元素，对齐之后y还有元素（至少一个），这种情况下可以进行异步操作，把x最后一个元素变成y的最后一个元素，这样就可以考虑y去掉最后一个元素的情况了。

![image-20201019092152588](https://i.loli.net/2020/10/19/pWI2BMjuKyriOCF.png)

第二种情况，x最后一位元素在y最后两个元素之间，所以和第一种情况一样。

![image-20201019092359820](https://i.loli.net/2020/10/19/lkdpBCgwxXFimEH.png)

，这种情况，x,y最后一位元素的位置重合，根据他们是否相等来判断是否需+1

![image-20201019092444744](https://i.loli.net/2020/10/19/MSwWxdFum8Rr7a4.png)

总结一下啊：

![image-20201019092501707](https://i.loli.net/2020/10/19/pXkMghQ613T4NU5.png)

![image-20201019092531572](https://i.loli.net/2020/10/19/vb3zsQ72mnjlNge.png)

做一个证明

1. ED[m-1,n]一定是x[1:m-1]和y[1:n]的最小编辑距离，否则存在k<ED[m-1,n]使得x[1:m-1]可以变成y，那么k+1$\leq$ED[m-1,n]次操作之后就可以把x转化为y了，矛盾！

2. ED[m-1,n-1]一定是x[1:m-1]和y[1:n-1]的最小编辑距离，否则存在k<ED[m-1,n-1]使得x[1:m-1]可以变成y[1:m-1]，如果x[m]=y[n]那么k步我们可以把x变成y，那么k<ED[m-1,n-1]次操作之后就可以把x转化为y了，矛盾！如果x[m]$\neq$y[n]那么k+1步我们可以把x变成y，那么k+1<ED[m-1,n-1]+1，矛盾！

3. 同上

   

#### 重叠子问题：

![image-20201019093504486](https://i.loli.net/2020/10/19/4jBShDgLym9i3vn.png)

显然，计算ED[m-1,n]和ED[m-1,n-1]的时候都会用到ED[m-2,n-1]

#### 递归求解过程：

我们知道

![image-20201019093553102](https://i.loli.net/2020/10/19/wrC5d4EAgYqsKyI.png)



因此我们需要求出左、上和左上的元素才可以求出当前的值

#### 算法伪代码

![image-20201019104643979](https://i.loli.net/2020/10/19/xUPE4ApqjNov9w3.png)

![image-20201019104735875](https://i.loli.net/2020/10/19/9ligXPq3EMUIpe6.png)

利用B记录一下路径的信息，利用E来存储代价值。

#### 构造最优解

![image-20201019105109187](https://i.loli.net/2020/10/19/qELgfB2i6p41GFP.png)

这里我们根据B中存储的信息来进行编辑序列的构造。

注意一下边界条件，如果j=0，也就是y是没有元素的，直接删除x串，如果i=0同理，不过我们采取是直接插入元素让x变成y的操作（我们为了方便起见都是由x变成y）

- 作业1：输入为CRONALDO和RENATO，填写计算二者最小编辑距离的矩阵E和B

|       | $y_j$ | R      | E      | N      | A      | T      | O      |
| ----- | ----- | ------ | ------ | ------ | ------ | ------ | ------ |
| $x_i$ | 0     | 1      | 2      | 3      | 4      | 5      | 6      |
| C     | 1     | ↖1     | ↖2     | ↖3     | ↖4     | ↖5     | ↖6     |
| R     | 2     | ==↖1== | ↖2     | ↖3     | ↖4     | ↖5     | ↖6     |
| O     | 3     | ↑2     | ==↖2== | ↖3     | ↖4     | ↖5     | ↖5     |
| N     | 4     | ↑3     | ↖3     | ==↖2== | ←3     | ←4     | ←5     |
| A     | 5     | ↑4     | ↖4     | ↑3     | ==↖2== | ←3     | ←4     |
| L     | 6     | ↑5     | ↖5     | ↑4     | ==↑3== | ↖3     | ↖4     |
| D     | 7     | ↑6     | ↖6     | ↑5     | ↑4     | ==↖4== | ↖4     |
| O     | 8     | ↑7     | ↖7     | ↑6     | ↑5     | ↖5     | ==↖4== |

- 作业2：完成最小编辑距离的优化解的构造算法，输入x和y，输出基本操作序列，将x转换为y

基本操作接口：

```python
(1) Insert(pos, a)
(2) Modify(pos, b)
(3) Delete(pos)
```

定义优化解构造算法输出序列的算法：

- 打印构造信息

```c++
printConstructInfo(x,y){
  (E,B) <- MinimalEditDistance(x,y);//获取最优解的信息
  m <- len(x);
  n <- len(y);
  result <- E[m,n];
  print(result);
  printDetailInfo(x,y,B);
}
```

- 打印详细信息

```c++
printDetailInfo(x,y,B){
  m <- len(x);
  n <- len(y);
  if B[m,n]='↖'{
    print(x[1:m-1],y[1:n-1],B);//先打印前面的构造信息
    if x[m-1]≠y[n-1]{
      print(Modify(m,y[n])); //如果两者不同，说明需修改。打印信息：x的第m个位置被修改为了y[n]
    }
  }
  else if B[m,n]='←'{
    print(x[1:m],y[1:n-1],B);
    print(Insert(m,y[n])); //打印信息：x的第m个位置插入了y[n]
  }
  else{
    print(x[1:m-1],y[1:n],B);
    print(Delete(m)); //打印信息：x的第m个位置被删除了
  }
}
```





### 复杂度分析

1. 时间复杂度：两层循环，为O(mn)
2. 空间复杂度：ED是(n+1)(m+1)的，B是mn的，和之前一样B可以省略（在O(1)）时间内可以判断出方向。和之前一样可以优化为O(min{m,n})的。

