# 分治和减治

## 分治法的原理

### 三步走

1. divide：划分子问题
2. conquer：求解各个子问题
3. combine：合并子问题的解

### 分析过程

1. 建立递归方程
2. 求解

### 递归方程的建立方法

设输入大小为n，T(n)为时间复杂性

n<c时，$T(n)=\theta(1)$

![image-20201019141913132](https://i.loli.net/2020/10/19/rI6V9DagJy2AmxS.png)

## 减治法的原理

原始问题划分成某一个子问题进行计算的方法。可以理解为分支问题中后面的项是常数。

![image-20201019152819524](https://i.loli.net/2020/10/19/unMPA8lUCas2WqO.png)

## 问题一、排序算法（简略谈谈）

### quicksort

1. divide: 数组按照pivot切一刀，划分为两个subarray
2. conquer：迭代地对于两个subarray进行quicksort
3. combine：无

>简单聊聊正确性证明：三步走
>
>1. 初始阶段：循环开始之前循环不变量成立
>2. 循环阶段：每次执行循环不变量成立
>3. 终止阶段：算法结束之后循环不变量保证算法正确。

![image-20201019144459083](https://i.loli.net/2020/10/19/YJIxnzl5cW97qiA.png)

![image-20201019144520248](https://i.loli.net/2020/10/19/rqjxOatdn2VXe5w.png)

![image-20201019144532859](https://i.loli.net/2020/10/19/Q6B89NwLozMDrlp.png)

4. 复杂度分析：

   $T(n)=2T(n/2)+\theta(n)$

   $T(n)=\theta(n\log n)$

   > 我们为了防止最坏情况的出现，我们可以使用随机化，就是选pivot的时候随机选。可以证明期望复杂度是O(nlogn)

排序问题的下界是，一个高度为h的二叉决策树的某一个路径的长度。其中，
$$
2^{h}\geq n!
$$
我们有$h\geq log(n!)=\Omega (nlogn)$

## 问题二、最近点对问题

### 问题建模

1. 输入：欧氏空间点集合$Q$
2. 输出：$A,B\in Q,\\ Dis(A,B)=Min\{Dis(P_i,P_j)|P_i,P_j\in Q\}$

### 算法

### 复杂度分析

## 问题

### 问题建模

1. 输入：
2. 输出：

### 算法

### 复杂度分析

## 问题

### 问题建模

1. 输入：
2. 输出：

### 算法

### 复杂度分析

## 问题

### 问题建模

1. 输入：
2. 输出：

### 算法

### 复杂度分析

## 问题

### 问题建模

1. 输入：
2. 输出：

### 算法

### 复杂度分析 

